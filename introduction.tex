% Enterprise JSF project.
%
% Copyright 2022 e-Contract.be BV. All rights reserved.
% e-Contract.be BV proprietary/confidential. Use is subject to license terms.

\chapter{Introduction}

Within this chapter we give a brief overview of JSF \cite{JSF23}.

\section{Basic Project Structure}
Basic Maven \cite{ApacheMaven} \texttt{pom.xml} file.
\lstinputlisting[language=XML]{helloworld/pom.xml}

This Maven POM file will create a deployable WAR file, as indicated by the \texttt{package} element.

Basic \texttt{src/main/webapp/index.xhtml} file.
\lstinputlisting[language=XML]{helloworld/src/main/webapp/index.xhtml}

You need the following minimal \texttt{src/main/webapp/WEB-INF/web.xml} configuration to activate JSF within the servlet container:
\lstinputlisting[language=XML]{helloworld/src/main/webapp/WEB-INF/web.xml}

Please notice here that an explicit configuration of \texttt{javax.faces.PROJECT\_STAGE} is really required here to disable web browser caching.
For proper development, the web browser caching has to be disabled.

You need the following minimal \texttt{src/main/webapp/WEB-INF/faces-config.xml} configuration to indicate to the application server which version of JSF you want to activate:
\lstinputlisting[language=XML]{helloworld/src/main/webapp/WEB-INF/faces-config.xml}

You need the following minimal \texttt{src/main/webapp/WEB-INF/beans.xml} configuration to activate CDI \cite{CDI2}:
\lstinputlisting[language=XML]{helloworld/src/main/webapp/WEB-INF/beans.xml}

Compile the example via:
\begin{lstlisting}[language=bash]
cd helloworld
mvn clean install
\end{lstlisting}

Start a WildFly \cite{WildFly} application server via:
\begin{lstlisting}[language=bash]
cd wildfly-26.1.0.Final/bin
./standalone.sh --server-config=standalone-full.xml
\end{lstlisting}

Deploy the \texttt{helloworld} WAR to the application server via:
\begin{lstlisting}[language=bash]
cd helloworld
mvn wildfly:deploy
\end{lstlisting}

Check out the deployed application within a web browser by navigating to:

http://localhost:8080/helloworld-1.0.0-SNAPSHOT/

\section{CDI Bean}

The source code of our first CDI \cite{CDI2} bean \texttt{HelloWorldController.java} looks as follows.
\lstinputlisting[language=Java]{helloworld/src/main/java/be/e_contract/jsf/helloworld/HelloWorldController.java}
Via the \texttt{@Named} annotation, we make our CDI bean available within the context of our JSF web application with a default naming.
Notice the usage of the \texttt{@PostConstruct} annotation to initialize our CDI bean when its lifecycle starts.

We can use this CDI bean within a JSF page as follows:
\lstinputlisting[language=XML]{helloworld/src/main/webapp/helloworld.xhtml}

Notice how we access the \texttt{value} property of our CDI bean via the \texttt{\#\{...\}} expression.

\section{Basic Input/Output}
\label{sec:basic-input-output}

In this example we do some basic input and output.
The CDI controller for this looks as follows:
\lstinputlisting[language=Java]{helloworld/src/main/java/be/e_contract/jsf/helloworld/InputOutputController.java}

Notice the usage of the \texttt{@ViewScoped} annotation to control the lifecycle of our CDI bean within the context of the JSF page.

JSF page:
\lstinputlisting[language=XML]{helloworld/src/main/webapp/input-output.xhtml}

When we click on the \texttt{h:commandButton}, the entire page is being reloaded with an updated value of course.


\section{AJAX}

The reloading of the entire JSF page can be avoided by using AJAX as shown in the following example JSF page.
\lstinputlisting[language=XML]{helloworld/src/main/webapp/ajax.xhtml}

Via the \texttt{f:ajax} tag we enable AJAX on the \texttt{h:commandButton} component.
The \texttt{execute} attribute instructs what has to be processed, while the \texttt{render} attributes defines what needs to be rendered again.

\section{Input Validation}

Enabling input validation on JSF input components is demonstrated in the following example.
\lstinputlisting[language=XML]{helloworld/src/main/webapp/validation.xhtml}

Here you will get an error message when the length of the input is less than 4.

\section{CSS}

Styling JSF can easily be done by attaching a CSS stylesheet as demonstrated within the following example.
\lstinputlisting[language=XML]{helloworld/src/main/webapp/css.xhtml}

With the CSS file under \texttt{src/main/webapp/resources/css/style.css}:
\lstinputlisting[language=CSS]{helloworld/src/main/webapp/resources/css/style.css}

Now JSF messages show up colored in red.

\section{Data Iterators}

JSF has several components to ease visualization of lists.
The following CDI controller holds a list of items that we want to visualize within a table on the JSF page.
\lstinputlisting[language=Java]{helloworld/src/main/java/be/e_contract/jsf/helloworld/DataController.java}

The JSF page uses a \texttt{h:dataTable} to visualize the list within a table.
\lstinputlisting[language=XML]{helloworld/src/main/webapp/datatable.xhtml}


\section{JSF Lifecycle}
Understanding the JSF page lifecycle is important.
Using the following custom \texttt{PhaseListener} you can follow the phases of each request.
\lstinputlisting[language=Java]{helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/ExamplePhaseListener.java}
This phase listener should be configured within \texttt{faces-config.xml} as follows:
\lstinputlisting[language=XML]{helloworld-ear/taglib/src/main/resources/META-INF/faces-config.xml}
Configure the WildFly logging within \texttt{standalone/configuration/standalone-full.xml} under the \texttt{subsystem} with namespace \texttt{urn:jboss:domain:logging:8.0} as follows.
\begin{lstlisting}[language=XML]
<periodic-rotating-file-handler name="EJSF" autoflush="true">
	<formatter>
		<named-formatter name="PATTERN"/>
	</formatter>
	<file relative-to="jboss.server.log.dir" path="ejsf.log"/>
	<suffix value=".yyyy-MM-dd"/>
	<append value="true"/>
</periodic-rotating-file-handler>
<logger category="be.e_contract.jsf">
	<level name="DEBUG"/>
	<handlers>
		<handler name="EJSF"/>
	</handlers>
</logger>
\end{lstlisting}
You can follow this log via:
\begin{lstlisting}[language=bash]
	cd wildfly-26.1.0.Final/standalone/log
	tail -F ejsf.log
\end{lstlisting}
Within Figure \ref{fig:life-cycle} we visualized the JSF request lifecycle.
\begin{figure}[htbp]
	\begin{center}
		\includegraphics[scale=0.7]{life-cycle}
		\caption{JSF request lifecycle.}
		\label{fig:life-cycle}
	\end{center}
\end{figure}
Please notice that we did not depict every possible state transition within this diagram.
We give a description of each JSF phase.
\begin{description}[style=nextline]
	\item[Restore View]
	During this initial phase, the \texttt{UIViewRoot} component tree is reconstructed using the corresponding XHTML page.
	\item[Apply Request Values]
	During this phase, each component decodes the request parameters to update its local values.
	This is done via the \texttt{decode} method of each involved component.
	\item[Process Validations]
	During this phase, all convertors and validators are executed against the component local values.
	\item[Update Model Values]
	During this phase, the backing beans properties are updated with the components local values.
	\item[Invoke Application]
	During this phase, all actions are executed.
	\item[Render Response]
	During this final phase, the components are rendered.
	The response state is also saved for subsequent access during the restore view phase.
\end{description}
Not every JSF request will walk through all these phases. For example, an initial JSF request will directly jump from \textbf{Restore View} to \textbf{Render Response} as there is no input to process.
Similarly, when a validator fails during the \textbf{Process Validations} phase, we directly jump to \textbf{Render Response} as we don't want to process invalid input towards our backing beans.

\section{Templates}

Facelets stuff here.