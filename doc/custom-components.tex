% Enterprise JSF project.
%
% Copyright 2022-2024 e-Contract.be BV. All rights reserved.
% e-Contract.be BV proprietary/confidential. Use is subject to license terms.

\chapter{Custom Components}
Besides the standard JSF component, one can also construct custom components.
Within the chapter we explain how to construct custom JSF components.
There are two types of custom JSF components:
\begin{itemize}
	\item Composite Components that are defined using Facelets.
	\item Custom Renderer Components that are primarily defined using Java.
\end{itemize}
Within this chapter we show how to define both of these custom component types.

\section{Tag Library}

We structure the example application as deployable EAR. This is depicted in Figure \ref{fig:ear}.
\begin{figure}[htbp]
	\begin{center}
		\includegraphics[scale=1.0]{ear}
		\caption{EAR project structure.}
		\label{fig:ear}
	\end{center}
\end{figure}
While you can put custom JSF components directly within your web application archive (WAR) file,
we strongly advice to directly isolate them within a separate JAR.
Some reasons to do so:
\begin{itemize}
	\item Within larger teams, this allows developers to specialize and take responsibility over the custom JSF library.
	Creating custom JSF components requires specific skills, that not all developers necessarily master.
	\item Most applications have multiple portals, and hence multiple WAR files. For example: an end-user portal and an administrative portal. A separate JSF library allows you to use the same components within different WAR artifacts.
	\item Directly isolating custom JSF components within their proper library makes it easier to later on propagate generic JSF components to for example a company-wide JSF library, or to push it even further towards open source (for example PrimeFaces Extensions).
	\item This allows you to have an extra test WAR specifically targeting the development of your JSF components.
	This avoid the need to deploy your entire business application during component development and thus will have a positive impact on the development speed of your custom components.
\end{itemize}
The Maven structure for our Java EE EAR project has been depicted in Figure \ref{fig:ear-structure}.
\begin{figure}[htbp]
	\begin{center}
		\includegraphics[scale=0.8]{ear-structure}
		\caption{EAR Maven project structure.}
		\label{fig:ear-structure}
	\end{center}
\end{figure}

The Maven parent POM of our project looks as follows.
\lstinputlisting[language=XML]{../examples/helloworld-ear/pom.xml}
We defined the Java EE API \texttt{javaee-api} as global dependency for all our modules.
We defined the \texttt{javaee-api} dependency with \texttt{scope} value \texttt{provided} since we don't want this dependency, nor any of its transitive dependencies, to be included within our WAR/EAR artifacts.
It is the application server itself that will provide these dependencies as part of its runtime environment.

The Maven POM of our tag library JAR module looks as follows.
\lstinputlisting[language=XML]{../examples/helloworld-ear/taglib/pom.xml}
Via the parent POM, our tag library inherently has \texttt{javaee-api} as its dependency.

The Maven POM of our WAR module looks as follows.
\lstinputlisting[language=XML]{../examples/helloworld-ear/war/pom.xml}
Obviously our WAR artifact has a dependency on our tag library.
\begin{TIP}{Maven module naming}
	We use as \texttt{groupId} of project modules the concatenation	of the \texttt{parent} \texttt{groupId} and \texttt{artifactId}.
	This has the advantage of yielding a clean directory structure when pushing the project towards a Maven repository.
	Hence every artifact produced by this project, can be found under the same directory structure within the Maven repository.
\end{TIP}

The content of the WAR is similar to the initial example given in Chapter \ref{chap:introduction}.

The Maven POM of our deployable EAR module looks as follows.
\lstinputlisting[language=XML]{../examples/helloworld-ear/ear/pom.xml}

The tag library itself is a regular JAR with a specific structure (see also Figure \ref{fig:ear-structure} on page \pageref{fig:ear-structure}).
The most important file is our\\
\texttt{src/main/resources/META-INF/ejsf.taglib.xml} tag library descriptor file:
\lstinputlisting[language=XML,linerange=1-10]{../examples/helloworld-ear/taglib/src/main/resources/META-INF/ejsf.taglib.xml}
You can name this file anyway you want, as long as it ends with \texttt{.taglib.xml}.
The above \texttt{.taglib.xml} tag library descriptor file already contains some declarations of custom tags that we will define later on (file not shown completely here).
As you can see, our custom JSF components will live under the \texttt{urn:be:e-contract:enterprise-jsf} namespace.

You can compile the example as follows.
\begin{lstlisting}[language=bash]
	cd examples/helloworld-ear
	mvn clean install
\end{lstlisting}

Deploy the \texttt{helloworld-ear} EAR to the WildFly application server via:
\begin{lstlisting}[language=bash]
	cd examples/helloworld-ear/ear
	mvn wildfly:deploy
\end{lstlisting}

You can check out the deployed application within a web browser by navigating to the following URL:

http://localhost:8080/helloworld-ear/

\section{Validator}
\label{sec:validator}
We start off with our first custom JSF component, a validator.
A custom validator simply has to implement the \texttt{Validator} interface as shown in the following example.
\lstinputlisting[language=Java]{../examples/helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/validator/ExampleValidator.java}
Via the \texttt{@FacesValidator} annotation we register our custom validator within the JSF runtime with a unique identifier.
Important for validators is to let a \texttt{null} or empty value pass to allow for non-required input fields.

We register this custom validator within our \texttt{.taglib.xml} tag library descriptor as follows.
\lstinputlisting[language=XML,linerange=exampleValidator]{../examples/helloworld-ear/taglib/src/main/resources/META-INF/ejsf.taglib.xml}
The value of the \texttt{validator-id} element has to correspond with the value of the \texttt{@Faces\allowbreak Validator} annotation.
This allows us to use our validator via the \texttt{exampleValidator} tag.
Additional advantage is that we can easily document the validator within the tag library descriptor, making life easier towards developers that have to integrate our custom components.

An example usage of our custom validator is given below.
\lstinputlisting[language=XML]{../examples/helloworld-ear/war/src/main/webapp/validation.xhtml}
Hence entering "foobar" as input will result in a JSF error message being displayed.


\subsection{Validator Parameters}
Validators can be parameterized to tune its behavior. 
A JSF  validator with a parameter attribute looks as follows.
\lstinputlisting[language=Java]{../examples/helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/validator/ParameterValidator.java}
This validator implements the \texttt{StateHolder} interface to ensure that its state is correctly preserved over different requests.
The \texttt{saveState} and \texttt{restoreState} methods take care of preserving the state of our validator fields.

We register this custom validator within our \texttt{.taglib.xml} tag library descriptor as follows.
\lstinputlisting[language=XML,linerange=parameterValidator]{../examples/helloworld-ear/taglib/src/main/resources/META-INF/ejsf.taglib.xml}
Obviously, every attribute that we define on our validator requires corresponding setters and getters on the validator class implementation.
Notice that the attribute named \texttt{parameter} is marked as required.
Hence when using the validator, you must provide the \texttt{parameter} attribute.
Realize here that although the attribute is required, its value can be \texttt{null}.

An example usage of our custom validator is given below.
\lstinputlisting[language=XML]{../examples/helloworld-ear/war/src/main/webapp/validation-parameter.xhtml}

\section{Output Component}
In this section we construct our first "real" JSF component.
This component simply outputs its value.
An output component inherits from the \texttt{UIOutput} class.
To give you a better idea on where to position \texttt{UIOuput} in the class hierarchy of JSF,
we depicted the most important JSF classes within Figure \ref{fig:jsf-classes}.
\begin{figure}[htbp]
	\begin{center}
		\includegraphics[scale=0.8,rotate=90]{jsf-classes}
		\caption{Most important classes for a JSF component library developer.}
		\label{fig:jsf-classes}
	\end{center}
\end{figure}

The source code of our custom output JSF component is given below.
\lstinputlisting[language=Java]{../examples/helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/output/ExampleOutput.java}
As we are constructing an output component, we inherit from the \texttt{UIOutput} class.
Important here is to set the \texttt{id} attribute on our \texttt{span} HTML element to the value of client id.
This is required so that the JSF AJAX Javascript code can find our JSF component during response updates within the rendered HTML.
Hence even if the value is \texttt{null}, it is important to render the HTML with correct client id so that future AJAX updates can succeed.

We explicitly set the renderer type to \texttt{null} to prevent a warning when using Apache MyFaces \cite{myfaces} as JSF implementation.

Important here is to use \texttt{writeText} to output our \texttt{value}.
This gives us proper HTML escaping and hence prevents a gaping XSS vulnerability within our component if we would have been using the \texttt{write} method instead.

We register this custom component within our \texttt{.taglib.xml} tag library descriptor as follows.
\lstinputlisting[language=XML,linerange=exampleOutput]{../examples/helloworld-ear/taglib/src/main/resources/META-INF/ejsf.taglib.xml}

\begin{TIP}{XML Descriptors}
While JSF allows you to define the tag directly via the \texttt{@FacesComponent} annotation,
we prefer to use the classical XML descriptors for several reasons:
\begin{itemize}
	\item not everything can be declared via annotations.
	\item XML descriptors allow you to isolate the documentation of a component from the implementation.
	As not all developers are good technical writers, it can be very practical to have the component documentation separated from its implementation.
	\item there is nothing wrong with XML, really.
\end{itemize}
\end{TIP}

An example usage of our custom output JSF component is given below.
\lstinputlisting[language=XML]{../examples/helloworld-ear/war/src/main/webapp/output.xhtml}
We selectively update our custom output component via the \texttt{render="output"} attribute on the \texttt{f:ajax} tag when the user clicks the \texttt{h:commandButton} component.

\subsection{Output Component with Style}

In this example, we create an output component that is styled via a separate CSS style sheet.
Suppose we have an enumerate, which we want to visualize using different colors.
\lstinputlisting[language=Java]{../examples/helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/output/ExampleEnum.java}

The JSF output component to achieve this looks as follows:
\lstinputlisting[language=Java]{../examples/helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/output/ExampleStyledOutput.java}
In this example, we perform the rendering via a separate \texttt{Renderer} implementation.
Having a separate \texttt{Renderer} has several advantages.
\begin{itemize}
	\item It keeps the code of the component itself clean.
	\item The \texttt{Renderer} implementation focuses purely on the rendering/encoding (and decoding).
	\item Some frameworks provide a nice base class to implement a \texttt{Renderer}, which automatically forces you to have a separate rendering class.
\end{itemize}
Within our component we explicitly set the renderer type within the constructor via \texttt{setRendererType}.
This is actually only required to make \texttt{createComponent} to work without too much trouble.
If we don't do this, components created via \texttt{createComponent} can have the wrong renderer assigned.
See also Section \ref{sec:dynamic-components} \nameref{sec:dynamic-components} on page \pageref{sec:dynamic-components}.
Furthermore it is good practice to define the \texttt{COMPONENT\_TYPE} constant on each JSF component to ease component creation via the \texttt{createComponent} method.

We reference our CSS style sheet resource via the \texttt{@ResourceDependency} annotation.
Important here is a correct usage of the \texttt{library} attribute to clearly indicate to which web application or tag library the corresponding resource belongs.
Of course other resources, for example a Javascript resource, can be referenced in a similar way.

The implementation of the \texttt{Renderer} looks as follows.
\lstinputlisting[language=Java]{../examples/helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/output/ExampleStyledOutputRenderer.java}
Via the \texttt{@FacesRenderer} annotation we register our custom renderer within the JSF runtime.
Depending on the value of our enumerate, we change the \texttt{class} attribute value of our rendered \texttt{span} element.
Obviously the \texttt{encodeBegin} method now also receives our component as additional parameter.
Notice that we don't provide an implementation of the \texttt{encodeEnd} method as this only makes sense in case our component would also hold any child components.

The corresponding\\
\texttt{src/main/resources/META-INF/resources/ejsf/example-styled-output.css}\\
CSS style sheet resource file looks as follows:
\lstinputlisting[language=CSS]{../examples/helloworld-ear/taglib/src/main/resources/META-INF/resources/ejsf/example-styled-output.css}
Within this CSS style sheet we define an \texttt{example-styled-output} CSS class that is always used on our output \texttt{span} element.
Next to that we define a CSS class for each of our \texttt{ExampleEnum} values.
Here we simply play a bit with the colors of our output \texttt{span} element.

When creating CSS style sheets as part of a JSF component library, it is important to properly prefix your CSS classes to prevent clashes with other style sheets within your web application.
In our example, we prefixed every defined CSS class with \texttt{example-}.

We register this custom component and corresponding renderer within our \texttt{.taglib\allowbreak.xml} tag library descriptor as follows.
\lstinputlisting[language=XML,linerange=exampleStyledOutput]{../examples/helloworld-ear/taglib/src/main/resources/META-INF/ejsf.taglib.xml}

The following XHTML page demonstrates how to use this custom output component.
\lstinputlisting[language=XML]{../examples/helloworld-ear/war/src/main/webapp/output-styled.xhtml}

With the corresponding CDI controller,
\lstinputlisting[language=Java]{../examples/helloworld-ear/war/src/main/java/be/e_contract/jsf/helloworld/EnumOutputController.java}


\section{Input Component}
In this section, we construct a custom JSF input component.
The source code of our custom input JSF component is given below:
\lstinputlisting[language=Java]{../examples/helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/ExampleInput.java}
As we are constructing an input component, we inherit from the \texttt{UIInput} class.
We put an explicit \texttt{id} attribute containing the client id on our \texttt{span} HTML container element so JSF AJAX updates can locate our component.
Specific for input components is that we also \texttt{decode} incoming requests.

Our \texttt{input} element has a \texttt{name} attribute used to locate the request parameter during the \texttt{decode} phase.
Obviously the \texttt{name} attribute value has to contain the client id somehow to ensure that our component can unambiguously locate its parameters.

Notice the usage of the \texttt{getSubmittedValue()} and \texttt{setSubmittedValue()} methods during encoding and decoding.
The submitted value only gets propagated towards the actual value in case all input validators are happy.
Upon an input validation error, the component keeps working on the submitted value.
Hence within the \texttt{encodeBegin} method we give preference to \texttt{getSubmittedValue()} over \texttt{getValue()} to output the component's value.
This ensures that a user keeps seeing the invalid value in case of a validator error instead of the original value so that the error message is indeed consistent with the value being displayed.
We also clear previous validation errors via \texttt{setValid(true)} when decoding the submitted value.

We register this custom component within our \texttt{.taglib.xml} tag library descriptor as follows.
\lstinputlisting[language=XML,linerange=exampleInput]{../examples/helloworld-ear/taglib/src/main/resources/META-INF/ejsf.taglib.xml}

An example usage of our custom input JSF component is given below.
\lstinputlisting[language=XML]{../examples/helloworld-ear/war/src/main/webapp/input.xhtml}
When trying out this example and you first enter a valid value, for example "hello", and next an invalid value "foobar", you will indeed see "foobar" as input value and the JSF error message correspondingly whining about "foobar" as expected.
Hence as long as the submitted value is invalid, our input component keeps working with this submitted value instead of the actual model value (which is retrieved via \texttt{getValue()}).

\section{Rendering Children}
In this example, we demonstrate how to render the children of a component.
We do this by constructing our own \texttt{panelGrid} component.
The source code of this component is given below.
\lstinputlisting[language=Java]{../examples/helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/PanelGridComponent.java}
As this component is neither an input nor output component, we simply inherit from the \texttt{UIComponentBase} class.
This component uses a custom attribute named "columns" to define the number of columns to be rendered within the table.
Notice how we define a default value of "1" for our \texttt{columns} attribute within the \texttt{getColumns} method via the second parameter of the \texttt{getStateHelper().eval} method.
Via the \texttt{StateHelper} we instruct JSF to keep track of the internal state of our component.
Keep in mind that this state is used during the JSF restore phase.
Notice how we index our state within the \texttt{StateHelper} using a \texttt{PropertyKey} enumeration.
This is good common practice.

Via the \texttt{true} return value of the \texttt{getRendersChildren} method we indicate that we render our child components ourselves.
Within the \texttt{encodeChildren} method we render each child component via the \texttt{child.encodeAll} method invocations within our rendered HTML table.

We register this custom component within our \texttt{.taglib.xml} tag library descriptor as follows.
\lstinputlisting[language=XML,linerange=panelGrid]{../examples/helloworld-ear/taglib/src/main/resources/META-INF/ejsf.taglib.xml}

An example usage of our custom \texttt{panelGrid} component is given below.
\lstinputlisting[language=XML]{../examples/helloworld-ear/war/src/main/webapp/panel-grid.xhtml}


\section{AJAX Events}
JSF components can trigger AJAX events that are handled at the server-side.
The following component demonstrates how to fire such AJAX event at the client-side, and how to capture and process the corresponding AJAX call at the server-side.
The source code of our custom JSF component that can fire AJAX events looks as follows.
\lstinputlisting[language=Java]{../examples/helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/ExampleAjax.java}
A component that supports client-side events, needs to implement the \texttt{ClientBehavior\allowbreak Holder} interface.
Our component defines a \texttt{click} client-side event as indicated via the \texttt{getEvent\allowbreak  Names} method.
This is also the default event as indicated via the \texttt{getDefault\allowbreak EventName} method.

Within the \texttt{encodeBegin} method we weave in the client behavior Javascript code via the \texttt{onclick} Javascript hook of our HTML button.
At the server-side, we process our event within the \texttt{decode} method.
First we verify whether the incoming request is really meant for our component by checking the client id, after which we delegate further decoding to the specific client behavior.
Notice that, despite the naming of \texttt{ClientBehavior}, client behaviors can indeed also trigger events at the server-side.

We register this custom component within our \texttt{.taglib.xml} tag library descriptor as follows.
\lstinputlisting[language=XML,linerange=exampleAjax]{../examples/helloworld-ear/taglib/src/main/resources/META-INF/ejsf.taglib.xml}

An example usage of our custom JSF component is given below.
\lstinputlisting[language=XML]{../examples/helloworld-ear/war/src/main/webapp/ajax.xhtml}
Since we specified "click" as our default client-side event, we don't have to explicitly specify it via the \texttt{event="click"} attribute within \texttt{f:ajax}.

The corresponding CDI controller looks as follows:
\lstinputlisting[language=Java]{../examples/helloworld-ear/war/src/main/java/be/e_contract/jsf/helloworld/AjaxController.java}
The \texttt{ajaxListener} method is invoked when the user clicks the button on the page.

\subsection{Custom AJAX Events}

One can also create custom AJAX events that contain component specific parameters.
An example custom event with some parameter looks as follows.
\lstinputlisting[language=Java]{../examples/helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/ExampleAjaxBehaviorEvent.java}
This custom AJAX event inherits from the base \texttt{AjaxBehaviorEvent} class and simply adds a custom parameter called \texttt{parameter}.

This custom AJAX event is passed as parameter to the CDI bean listener method as follows.
\lstinputlisting[language=Java]{../examples/helloworld-ear/war/src/main/java/be/e_contract/jsf/helloworld/AjaxCustomEventController.java}

The following example JSF component demonstrates how to fire such custom AJAX JSF event that contains a parameter passed from the client-side to the server-side.
\lstinputlisting[language=Java]{../examples/helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/ExampleAjaxEventComponent.java}
We don't use the \texttt{getScript} method of the client behavior here as we want to pass on our own parameter.
Within the \texttt{decode} method we decode the client behaviors as usual.
Only additional thing here is that, within the \texttt{queueEvent} method, we like upgrade the generic \texttt{AjaxBehaviorEvent} to our own flavor \texttt{ExampleAjaxBehaviorEvent}.
Notice here that within the \texttt{queueEvent} method we don't have to recheck whether the behavior source indeed corresponds with our component since the \texttt{decode} method already did this, and only fired the AJAX event towards our component anyway.
Important within the \texttt{queueEvent} method is to keep delegating the processing of events towards \texttt{super.queueEvent} for events that we are not interested in.
Within the \texttt{@ResourceDependencies} annotation we reference the different Javascript resources required by our component at the client-side.

The corresponding \texttt{example-ajax-event.js} Javascript resource file looks as follows:
\lstinputlisting[language=Javascript]{../examples/helloworld-ear/taglib/src/main/resources/META-INF/resources/ejsf/example-ajax-event.js}
Here we use the JSF client-side Javascript API \texttt{jsf.ajax.request} method to perform an AJAX request.
Hence we included the \texttt{jsf.js} Javascript JSF resource within the \texttt{@ResourceDependencies} annotation.
Via \texttt{options.params} we pass our custom parameter.
Our parameter name is prefixed with the client id of our component.
This allows our component to unambiguously locate its parameters within the \texttt{queueEvent} method.

We register this custom component within our \texttt{.taglib.xml} tag library descriptor as follows.
\lstinputlisting[language=XML,linerange=exampleAjaxEvent]{../examples/helloworld-ear/taglib/src/main/resources/META-INF/ejsf.taglib.xml}

An example usage of our custom JSF component is given below.
\lstinputlisting[language=XML]{../examples/helloworld-ear/war/src/main/webapp/ajax-event.xhtml}

\section{JSF Component with client-side API}
Modern JSF libraries like PrimeFaces provide a very rich client-side API on their components.
Hence the (server-side) JSF components can get enriched by client-side counterparts called widgets.
These widgets have their own lifecycle and obviously are able to expose some API.
Within this section we demonstrate how this can be achieved.
The JSF component source code for this example looks as follows,
\lstinputlisting[language=Java]{../examples/helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/ExampleWidget.java}
We activate the client-side Javascript on our rendered component by setting some \texttt{data-} attributes that will be picked up by our Javascript code.
Via the \texttt{data-ejsf-widget\allowbreak -update} attribute we indicate that the client-side should take some action.
Similar behavior could be accomplished via some inline Javascript.
However, this could lead to problems when activating CSP (Content Security Policy).

The \texttt{ejsf-widget.js} Javascript resource looks as follows:
\lstinputlisting[language=Javascript]{../examples/helloworld-ear/taglib/src/main/resources/META-INF/resources/ejsf/ejsf-widget.js}
Here we basically create a generic \texttt{Widget} class within the \texttt{ejsf} namespace that allows us to resolve widgets on the client-side using the \texttt{EJSF} method.
Via the \texttt{registerWidgetType} method we can register concrete widget classes for our JSF components.
During document loading, we instantiate all the widgets according to their registered type.
A \texttt{Widget} has a certain lifecycle. After the construction of the widget instance, we call either \texttt{init} or \texttt{update} depending on whether we have an initial construction, or an update on an existing widget.
Before a widget gets destroyed, we invoke the \texttt{destroy} method on it.
Notice how we use \texttt{jsf.ajax.addOnEvent} to make sure that we properly update widgets after an AJAX call as been completed.
Once a widget has been updated to reflect the new state of its corresponding JSF component, we remove its \texttt{data-ejsf-widget-update} update marker attribute.

The \texttt{ejsf-widget-example.js} Javascript resource, which contains a concrete \texttt{Widget} implementation, looks as follows:
\lstinputlisting[language=Javascript]{../examples/helloworld-ear/taglib/src/main/resources/META-INF/resources/ejsf/ejsf-widget-example.js}
Our \texttt{ExampleWidget} Javascript class simply exposes a \texttt{setValue} method to change the content of the widget element.
Further we register our widget type via \texttt{ejsf.register\allowbreak Widget\allowbreak Type} so that it can get picked up during page loading by the \texttt{ejsf-widget.js} widget frameworking.
We override the \texttt{init}, \texttt{update}, and \texttt{destroy} methods to simply demonstrate the lifecycle of our custom widget.

We register this custom component within our \texttt{.taglib.xml} tag library descriptor as follows.
\lstinputlisting[language=XML,linerange=exampleWidget]{../examples/helloworld-ear/taglib/src/main/resources/META-INF/ejsf.taglib.xml}

An example usage of our custom JSF component is given below.
\lstinputlisting[language=XML]{../examples/helloworld-ear/war/src/main/webapp/widget.xhtml}
The corresponding CDI controller looks as follows:
\lstinputlisting[language=Java]{../examples/helloworld-ear/war/src/main/java/be/e_contract/jsf/helloworld/WidgetController.java}
Please keep in mind that the above construct is just a very rudimentary example.
JSF libraries like PrimeFaces offer similar functionality out-of-the-box that goes way beyond what we demonstrated here.
Good advice: don't reinvent the wheel, but use libraries like PrimeFaces.
See also Chapter \ref{chap:primefaces} for more information on PrimeFaces.

\section{Client Behavior}
JSF allows you to define components that only perform some functionality on the client-side.
These are called client behaviors.
Notice that AJAX events are also client behaviors, but they also decode at the server-side, and thus generate corresponding server-side events.
The point here is that you can have client behaviors that do not trigger anything at the server-side.
\begin{figure}[htbp]
	\begin{center}
		\includegraphics[scale=0.8,rotate=90]{behavior}
		\caption{The most important classes related to JSF client behavior.}
		\label{fig:behavior}
	\end{center}
\end{figure}
In Figure \ref{fig:behavior} we depicted the interfaces and classes related to JSF client behavior, of which the AJAX client behavior is the most prominent.

In this section we demonstrate an example client behavior where we change the color of a button when we move over it with the mouse.
Usage of this custom client behavior looks as follows.
\lstinputlisting[language=XML]{../examples/helloworld-ear/war/src/main/webapp/client-behavior.xhtml}

The custom client behavior source code is given below,
\lstinputlisting[language=Java]{../examples/helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/behavior/ExampleClientBehavior.java}
A custom client behavior simply has to extend the \texttt{ClientBehaviorBase} class.
Via the \texttt{@FacesBehavior} annotation we register our custom client behavior within the JSF runtime.

The corresponding client behavior renderer is given below.
\lstinputlisting[language=Java]{../examples/helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/behavior/ExampleClientBehaviorRenderer.java}
This renderer simply attaches its Javascript method invocation via the \texttt{getScript} method.
Notice that the \texttt{exampleClientBehavior} Javascript method has access to an \texttt{event} variable that holds the triggered DOM event instance.
Via the \texttt{@ResourceDependencies} annotation we reference all resources required by our client behavior at the client-side.

Via a custom tag handler we attach our client behavior to its parent component.
Remember that a tag handler performs the "translation" from our Facelets elements towards a JSF component view tree.
The source code of the tag handler looks as follows.
\lstinputlisting[language=Java]{../examples/helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/behavior/ExampleClientBehaviorTagHandler.java}
A custom tag handler has to extend the \texttt{TagHandler} class.
Important here is to instantiate the custom behavior via \texttt{application.createBehavior} to ensure that the \texttt{@ResourceDependency} annotations on the renderer are interpreted by JSF runtime.
We simply attach our behavior to the "mouseover" and "mouseout" client events of our parent \texttt{ClientBehaviorHolder} component.

The \texttt{example-client-behavior.js} JavaScript resource looks as follows:
\lstinputlisting[language=Javascript]{../examples/helloworld-ear/taglib/src/main/resources/META-INF/resources/ejsf/example-client-behavior.js}
Since we use only a single client-side event method for both "mouseover" and "mouseout" events, we have to distinguish between the two event types within our event handling method itself.
We do this by means of the \texttt{event} parameter.

The \texttt{example-client-behavior.css} CSS style sheet looks as follows:
\lstinputlisting[language=CSS]{../examples/helloworld-ear/taglib/src/main/resources/META-INF/resources/ejsf/example-client-behavior.css}

We register this custom component and its corresponding tag handler within our \texttt{.taglib.xml} tag library descriptor as follows.
\lstinputlisting[language=XML,linerange=exampleClientBehavior]{../examples/helloworld-ear/taglib/src/main/resources/META-INF/ejsf.taglib.xml}
Our custom tag handler needs to be registered using its full class name under the \texttt{handler-class} element.

\section{Composites}
JSF allows us to define components entirely within XHTML using Facelets.
Such components are called composite components, as they are basically a composition of already existing JSF components.
An example composite component \texttt{exampleComposite.xhtml} looks as follows.
\lstinputlisting[language=XML]{../examples/helloworld-ear/taglib/src/main/resources/META-INF/resources/ejsf/exampleComposite.xhtml}
Important here is to put an \texttt{id} attribute with \texttt{cc.clientId} value on the root element so that JSF AJAX updates can locate our composite component properly.
When defining composite components, always pay special attention to provide a complete and correct \texttt{cc:interface} descriptor.
Thay way your IDE can give you code completion hints about the parametrization of your composite component.
Via \texttt{cc.attrs} you can get access to your composite component's attributes.

An example usage of our composite component is given below.
\lstinputlisting[language=XML]{../examples/helloworld-ear/war/src/main/webapp/composite.xhtml}
\begin{TIP}{Forms}
Never use \texttt{h:form} directly within your composite component, even if the component requires one to function (due to AJAX for example).
Rationale: if a developer puts another \texttt{h:form} around your composite component, you end up having an HTML form within an HTML form, which is pretty foobar.
\end{TIP}

\subsection{Backing Component}
A composite component can be further enhanced using a backing component.
We demonstrate such construct within the following example.
This composite component allows us to input a period (days and hours).
The \texttt{inputPeriod.xhtml} composite component XHTML source looks as follows.
\lstinputlisting[language=XML]{../examples/helloworld-ear/taglib/src/main/resources/META-INF/resources/ejsf/inputPeriod.xhtml}
Via the \texttt{componentType} attribute on the \texttt{cc:interface} element we refer to the backing component.
Using the \texttt{binding} attribute we bind JSF components to our backing component.
Via the \texttt{cc} expression language variable we can access properties and methods of our backing component.

The corresponding backing component source code looks as follows.
\lstinputlisting[language=Java]{../examples/helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/ExampleBackingComponent.java}
A backing component always has to implement the \texttt{NamingContainer} interface.
When a component implements the \texttt{NamingContainer} interface, the JSF runtime will ensure that the client ids of its child components are unique by prefixing the identifiers with the identifiers of the parent component.
Hence it we have multiple instances of our \texttt{NamingContainer} implementing component, the JSF runtime will ensure that we have unique client-side identifiers.
This is important to ensure that AJAX updates get delivered to the correct elements within the DOM tree.
Important for composite backing components is to set 

\texttt{UINamingContainer.COMPONENT\_FAMILY} as family.
Keep in mind that the component state should always be handled via the \texttt{StateHelper} as components are basically request scoped.
The only class level variables you should be using, are those for binding child components, as done for \texttt{hours} and \texttt{days} in our example code.

Notice here the setup of both \texttt{encodeBegin} and \texttt{processDecodes} methods.
We have to correctly handle the submitted value to ensure that input validations on our composite component use the correct intermediate value at all times.
E.g., if an input validation error occurs on value "xyz", an update of our component should still display "xyz".
Within the \texttt{encodeBegin} method we first update our child components using the submitted value, or if no submitted value is available, with the actual value.
Next we continue the rendering of our child components via the \texttt{super.encodeBegin} method.
Similarly within the \texttt{processDecodes} method we first decode our child components via the \texttt{super.processDecodes} method, and next we calculate our submitted value based on the submitted values of our child components.

An example usage of our composite component with backing component looks as follows:
\lstinputlisting[language=XML]{../examples/helloworld-ear/war/src/main/webapp/composite-input.xhtml}
With the corresponding CDI controller given by,
\lstinputlisting[language=Java]{../examples/helloworld-ear/war/src/main/java/be/e_contract/jsf/helloworld/InputPeriodController.java}

\subsection{Children and Facets}
In the following composite component we demonstrate the usage of children and facets.
We do so by constructing our own panel component.
The source code of our \texttt{panel.xhtml} composite component looks as follows.
\lstinputlisting[language=XML]{../examples/helloworld-ear/taglib/src/main/resources/META-INF/resources/ejsf/panel.xhtml}
We declare our custom facet, named \texttt{footer},
via the \texttt{cc:facet} element within the \texttt{cc:interface} section of our composite component.
The panel footer is only rendered when the \texttt{footer} facet has been set.
Via \texttt{cc:insertChildren} we insert our children within our composite component rendering lifecycle.
Our CSS style sheet gets loaded at the client-side via the \texttt{h:outputStylesheet} tag.

The corresponding CSS style sheet \texttt{panel.css} is given below.
\lstinputlisting[language=CSS]{../examples/helloworld-ear/taglib/src/main/resources/META-INF/resources/ejsf/panel.css}

An example usage of our panel composite component is given below.
\lstinputlisting[language=XML]{../examples/helloworld-ear/war/src/main/webapp/composite-panel.xhtml}

\section{Method Expressions}
When using \texttt{action} or \texttt{listener} attributes, behind the scenes JSF/EL is using method expressions.
To demonstrate the usage of \texttt{MethodExpression} we construct a custom \texttt{Converter}.
The source code of our custom converter looks as follows.
\lstinputlisting[language=Java]{../examples/helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/converter/GenericConverter.java}
A custom converter has to implement the \texttt{Converter} interface.
This custom \texttt{Converter} simply delegates its \texttt{getAsObject} and \texttt{getAsString} method implementations towards method expressions.
These method expressions are invoked like "just in time".
We implement the \texttt{StateHolder} interface to ensure that the state of our converter gets properly saved and restored by the JSF runtime.

Via a custom \texttt{TagHandler} we attach our custom converter to its \texttt{UIInput} input parent component.
The source code of our tag handler looks as follows.
\lstinputlisting[language=Java]{../examples/helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/converter/GenericConverterTagHandler.java}
Notice how we define the method signature via the parameters of the \texttt{getMethod\allowbreak Expression} method.
We instantiate our converter via the \texttt{application.createConverter} method.
This allows the JSF runtime to properly handle the lifecycle of our converter, and to inject CDI dependencies and such.

We register this custom component and its corresponding tag handler within our \texttt{.taglib.xml} tag library descriptor as follows.
\lstinputlisting[language=XML,linerange=genericConverter]{../examples/helloworld-ear/taglib/src/main/resources/META-INF/ejsf.taglib.xml}
Notice how we declare the method expression signature via the \texttt{method-signature} tags.

An example usage within a JSF page of our custom converter looks as follows.
\lstinputlisting[language=XML]{../examples/helloworld-ear/war/src/main/webapp/generic-converter.xhtml}
The \texttt{getAsObject} and \texttt{getAsString} attributes on our custom \texttt{genericConverter} converter are interpreted as method expressions that refer to methods of our CDI controller.

The corresponding CDI controller looks as follows.
\lstinputlisting[language=Java]{../examples/helloworld-ear/war/src/main/java/be/e_contract/jsf/helloworld/GenericConverterController.java}


\section{Dynamic Components}
\label{sec:dynamic-components}
In this section we demonstrate how to construct dynamic components, i.e., components that change behavior at runtime.
Imagine we have a list of objects, each object has its own type as shown in the following example CDI controller.
\lstinputlisting[language=Java]{../examples/helloworld-ear/war/src/main/java/be/e_contract/jsf/helloworld/DataController.java}
Each \texttt{Item} has its own \texttt{type} and corresponding \texttt{value}.

We want to construct a component that is capable of inputting this dynamically typed value, as shown in the example below.
\lstinputlisting[language=XML]{../examples/helloworld-ear/war/src/main/webapp/dynamic-input.xhtml}
Depending on the actual type of the item, the \texttt{dynamicInput} component changes its rendering accordingly.
Hence for a boolean we should render a checkbox instead of a regular text input field.

Our JSF component for this looks as follows.
\lstinputlisting[language=Java]{../examples/helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/DynamicInputComponent.java}
Via the \texttt{@ListenerFor} annotations we indicate that we want to receive \texttt{PostAddToView\allowbreak Event} events from the JSF runtime.
These events are fired towards the \texttt{processEvent} method.
During the \texttt{PostAddToViewEvent} event we add specific input components to the component tree within the \texttt{processEvent} method.
We add all possible input components here,  since at this point we don't know yet which exact type will be required at render/decode time and it is of eminent importance to keep the view root component tree stable during the lifecycle of the page, including the postbacks.

When programmatically adding JSF components to the JSF view root tree, it is important to always define a relative unique identifier for each component via the \texttt{setId} method.
Here we let our component to implement the \texttt{NamingContainer} interface.
This will ensure that all child components will have a unique client identifier.
Hence despite that we set the identifier for our child components simply to \texttt{text} and \texttt{boolean}, JSF will ensure unique client ids, even if there are multiple instances of our component within the same XHTML page.
Implementing \texttt{NamingContainer} has the additional advantage that it makes it very easy to locate child components via the \texttt{findComponent} method.

Within the \texttt{encodeBegin} method we give our component a client-side identifier.
This is important to ensure that AJAX updates can locate our component.

Via the \texttt{getRendersChildren} method we indicate that we take care of rendering/decoding our children.
And this is exactly what we do within the \texttt{encodeChildren} and \texttt{decode} methods where we delegate towards the appropriate child component depending on the actual item type.
Hence we selectively render the child component that is capable of handling the item type.

We register this custom component within our \texttt{.taglib.xml} tag library descriptor as follows.
\lstinputlisting[language=XML,linerange=dynamicInput]{../examples/helloworld-ear/taglib/src/main/resources/META-INF/ejsf.taglib.xml}


\section{UIData}
Visualization of data tables is a commonly recurring aspect when constructing business oriented web applications.
Within this section we demonstrate how to devise a custom table visualization.
The source code of our custom \texttt{UIData} component looks as follows.
\lstinputlisting[language=Java]{../examples/helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/datalist/DataList.java}

The source code of the corresponding rendered is given below.
\lstinputlisting[language=Java]{../examples/helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/datalist/DataListRenderer.java}
Notice how we play with the \texttt{setRowIndex} method to render our child components multiple times for all our rows.
Here the JSF runtime will take care of generating unique client identifiers for each iteration over the children.
This nicely highlights why they introduces the concept of client identifiers within JSF.
Within the Facelets page, the \texttt{id} attribute values are not necessarily unique (as opposed to plain XML where they have to be unique).
On the other hand, within the rendered HTML the \texttt{id} attribute values have to be unique according to the HTML specification.
Hence the JSF runtime needs to do some additional work to be able to map between JSF identifiers and client-side HTML identifiers.

We register this custom component and its corresponding renderer within our \texttt{.taglib\allowbreak .xml} tag library descriptor as follows.
\lstinputlisting[language=XML,linerange=dataList]{../examples/helloworld-ear/taglib/src/main/resources/META-INF/ejsf.taglib.xml}

The following example demonstrates the usage of our custom data list component.
\lstinputlisting[language=XML]{../examples/helloworld-ear/war/src/main/webapp/data-list.xhtml}
An important remark here is that we really need to put the (input) components within an \texttt{h:column} tag if we want to have proper decoding of the components within the custom data table.
This can be seen within the source code of the \texttt{UIData} class where specific decoding happens for \texttt{UIColumn} child components.


\section{EL functions}
The JSF Expression Language (EL) can be seen as the glue between JSF and the CDI controllers.
In this section we demonstrate how to add custom EL functions.
In the following example we use a custom \texttt{gcd} function to calculate the greatest common divisor of two given numbers.
\lstinputlisting[language=XML]{../examples/helloworld-ear/war/src/main/webapp/custom-function.xhtml}
Notice here the \texttt{ejsf} namespace prefix to invoke the \texttt{gcd} method within the EL expression.

This EL (expression language) function has to be defined as a public static Java function as shown below.
\lstinputlisting[language=Java]{../examples/helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/GreatestCommonDivisor.java}

We register this function within our \texttt{.taglib.xml} tag library descriptor as follows.
\lstinputlisting[language=XML,linerange=gcd]{../examples/helloworld-ear/taglib/src/main/resources/META-INF/ejsf.taglib.xml}
Via the \texttt{function-signature} tag we declare the signature of our custom EL function.

\section{Custom Variables}
\texttt{UIData} based components expose an EL variable named according to the value of the \texttt{var} attribute.
Within this section we demonstrate how to expose such custom EL variable ourselves.
Take the next example JSF page,
\lstinputlisting[language=XML]{../examples/helloworld-ear/war/src/main/webapp/custom-variable.xhtml}
Here our \texttt{ejsf:customVariable} JSF component exposes an EL variable named \texttt{example\allowbreak Var}.
As value of our custom EL variable we take the current date time.
Within the body of \texttt{ejsf:custom\allowbreak Variable} this variable can be used as expected via \texttt{\#\{exampleVar\}}.
As demonstrated within the above example, we can indeed nest \texttt{ejsf:customVariable} components.
Hence special care must be taken to ensure proper nesting of the corresponding exposed EL variable instances.

The corresponding JSF component looks as follows,
\lstinputlisting[language=Java]{../examples/helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/variable/CustomVariableComponent.java}
To ensure that our EL variable is available during all JSF phases, we extend both the \texttt{pushComponentToEL} and \texttt{popComponentFromEL} methods.
These two methods already take care of handling the \texttt{component} EL variable and hence are the perfect place to expose additional EL variables.

Within the \texttt{pushComponentToEL} method we first call the parent method to guard the original behavior.
We maintain a \texttt{ValueExpression} stack as (request scoped) context attribute to properly handle nesting of our component.
Via the \texttt{VariableMapper} we retrieve a potential previous value of our EL variable and save it on our stack.
Next we create a \texttt{ValueExpression} containing the local date time as string constant.
Via the \texttt{VariableMapper} we expose our custom EL variable.
We added a \texttt{Thread.sleep(5)} to have a distinct local date time value for each of our EL variable \texttt{ValueExpression} instances.

Within the \texttt{popComponentFromEL} method we call the parent method to guard the original behavior.
Next to that, we simply pop the previous \texttt{ValueExpression} for our custom EL variable (which could have been \texttt{null}) and expose it via the \texttt{VariableMapper}.

We register our component within the \texttt{.taglib.xml} tag library descriptor as follows.
\lstinputlisting[language=XML,linerange=customVariable]{../examples/helloworld-ear/taglib/src/main/resources/META-INF/ejsf.taglib.xml}

\section{CDI enabled JSF tag libraries}
At a certain point you will want to take advantage of CDI within your custom JSF tag library to get things done.
For example, you could have some metrics JSF component that fires a CDI event to collect metrics within your application from whatever component that \texttt{@Observes} the corresponding CDI event.
Special attention is required here to allow such construct to correctly function.
To be able to address the potential problems here, let us analyse a real-world application setup as depicted in Figure \ref{fig:real-world-ear}.
\begin{figure}[htbp]
	\begin{center}
		\includegraphics[scale=0.65, rotate=90]{real-world-ear}
		\caption{A real-world EAR.}
		\label{fig:real-world-ear}
	\end{center}
\end{figure}
Most applications have multiple portals:
\begin{itemize}
	\item An end-user portal facing the public internet.
	\item An administrator portal to be able to manage the application.
	\item Probably also a web service portal to allow for third-party integrations with your platform.
	Here we can throw in buzz words like SOA or microservices, whatever you want to name it.
	While you can define ad-hoc REST endpoints, for big applications this is a really bad idea.
	You want to use OpenAPI here to guarantee that your consumers are always in sync with your (JAX-RS) endpoint definitions.
	This also voids the need to write endless, and almost always out-of-sync, documentation for your endpoints; you can simply add the documentation directly within your OpenAPI specifications file which you can publish alongside your endpoints.
	Back in the days, we had WSDL-first within the context of JAX-WS SOAP based web services.
\end{itemize}
While you could of course combine all of these within a single WAR this is in general a bad idea from a security point-of-view.
Hence a real-world application will most likely have multiple portals.
Given the effort that it takes to construct a JSF tag library, you will want to use the same tag library within multiple portals of your application.
Obviously all portals use the same EJB/CDI model which contains your actual business logic and JPA based data model.
This is also the place where your MDB JMS message consumers live to handle the asynchronous (background) tasks.
While EJB offers \texttt{@Asynchronous}  business methods, this in generally should be avoided:
\begin{itemize}
	\item They are not part of the XA transaction.
	\item When they fail, there is no JMS retry semantics, not dead letter queue to be able to replay the method invocations later on.
\end{itemize}
Hence for background tasks that are manageable within real-world scenarios, you definitely have to use a persistent messaging system like JMS that integrates with the overall XA based transaction manager.

Now to come back to CDI enabled JSF tag libraries, these are best structured as depicted in Figure \ref{fig:cdi}.
\begin{figure}[htbp]
	\begin{center}
		\includegraphics[scale=0.7]{cdi}
		\caption{A JSF tag library that uses CDI.}
		\label{fig:cdi}
	\end{center}
\end{figure}
The problem arises from the fact that your JSF tag library could be used within multiple WARs all living within the same EAR.
You cannot simply put your JSF tag library within the \texttt{lib/} directory of your EAR since such library really needs to be activated within the context of a servlet container in order to function correctly.
If you start defining \texttt{@Named} CDI beans within the JSF tag library itself, your application server will most likely start complaining that your named CDI bean has been defined multiple times within the, let's call it, CDI namespace.
Hence the best/most portable construct, that also works on all Java EE application servers, is to have a separate CDI JAR that can be used by your JSF tag library via an EL based lookup.
Also, if you want to let your EJB/CDI model to reference a certain API exposed by your JSF tag library you cannot get around the construct to have an isolated API JAR.
Keep in mind that you should avoid using the JSF API within this CDI JAR, since consumers like your EJB/CDI model will normally not have access to the JSF API as it is meant to be used only within the context of a servlet container.

Notice that the above construct also works for simple WARs, where the CDI JAR is included within the WAR itself as depicted in Figure \ref{fig:cdi-war}.
\begin{figure}[htbp]
	\begin{center}
		\includegraphics[scale=0.7]{cdi-war}
		\caption{A JSF tag library that uses CDI within a WAR.}
		\label{fig:cdi-war}
	\end{center}
\end{figure}
\begin{ClownComputing}{An EAR? Really?}
Now it is true that in the beginning when CDI was introduced,
there were some problems within the context of EAR based deployments.
However, a modular EAR monolith is still a very good option.
By now, these problems have well-known workarounds and can thus be avoided.
If you browse a bit online, you will probably encounter that \textit{they} want to phase out EAR deployments or at least don't give it much attention anymore.
\textit{They} don't like EAR deployments.
It is important here to realize who \textit{they} are.
We are talking the people who drive the Jakarta EE specifications,
who coincidentally also happen to be paid by the big cloud providers.
Of course an EAR deployment is not interesting for a cloud provider.
When you package your application as an EAR,
there is only one thing to deploy, and hence only one thing to invoice for the cloud provider.
Much more interesting for a cloud provider is to shove the microservices bullshit down the throat of every developer,
which is very easy these days via the various social networks,
so the cloud provider can invoice 4 or 5 container/VM instances instead of one.
Also funny, in case of an application error,
you can start logging in into 5 consoles to dig through all the different logs instead of one single log.
Unless of course you find a log aggregator, in the form of a SaaS provider of course, which gives you yet another invoice to be paid.

Also, since every method invocation now is a REST call,
the application gets slower and slower as features are being added and the required interconnection between the different components becomes larger.
Of course the golden solution here is to cluster up your application,
which again triggers extra container/VM instances that can be invoiced by the said cloud provider.
After a while you burn so much money on your cloud provider, that for this price you can basically buy a new server yourself every few months.
If you find yourself in this situation, congrats, you fell into the clown computing trap.

Besides the pleasure of ranting about it,
of course under the right circumstances a SOA/microservices architecture makes sense (just like it did 20 years ago).
But you should never go black or white here, reality is gray.
Introduce SOA/microservices when \textbf{YOU} see a clear advantage to it:
\begin{itemize}
	\item Some part of your code/business model can be reused by multiple other applications.
	\item This part requires not too much interaction on its own with other subsystems.
	\item This part has entities with a certain persistent life-cycle and hence cannot be just isolated within for example a Java library or so.
\end{itemize}
If you cannot give a rational objective argumentation to do so,
then don't.
Argumentations like: "I read this online", or "this is what the cloud provider proposes", should go straight to the thrash can.
\end{ClownComputing}

\section{JSF runtime class loading}
The components within your JSF tag library might require third-party dependencies as some point.
Special attention is required if you want to avoid having to include those third-party dependencies even when the corresponding JSF tags are not used within your web application.
When the JSF runtime analyses your JSF tag library descriptor at startup, it will sometimes want to load a little bit too much.
If you encounter such class loading issues, you can always isolate the usage of those third-party dependencies within separate utility classes, preventing the JSF runtime of loading too much at startup.