% Enterprise JSF project.
%
% Copyright 2023 e-Contract.be BV. All rights reserved.
% e-Contract.be BV proprietary/confidential. Use is subject to license terms.

\chapter{Front-end Frameworks}
\begin{TODO}{Under Construction}
	This chapter is still a work in progress.
\end{TODO}
Within this chapter we compare a popular Javascript front-end framework with JSF from a developer's perspective.
To do so, we construct a simple CRUD (create-read-update-delete) application using both technologies.
We are looking for a somehow objective reasoning whether Javascript based front-end frameworks are really that better compared to JSF web applications.
Some metrics to compare are:
\begin{itemize}
	\item Easy to maintain/understand build-system.
	\item Amount of framework API you need to have deep understanding of.
	\item Simplicity of the constructed application.
	\item Maintainability of the constructed application.
\end{itemize}

\section{The Model}
Both applications should use the same model.
Here we simply maintain a list of items.
The front-end should be able to display all items, and to remove/add items.
Our \texttt{Item} class looks as follows:
\lstinputlisting[language=Java]{../examples/frameworks/model/src/main/java/be/e_contract/model/Item.java}
Within a real production model our \texttt{Item} would of course be a JPA entity to manage its persistence.
But to keep things simple here, we avoid introducing JPA.
As you can see from the code, we use the \texttt{name} field somehow as a primary key.

Our \texttt{Model} class looks as follows:
\lstinputlisting[language=Java]{../examples/frameworks/model/src/main/java/be/e_contract/model/Model.java}
Again, to keep things simple we don't bother about aspects like transactionality, concurrency, security.
We do however introduce a "business" exception named \texttt{ExistingItem\allowbreak Exception} to be able to demonstrate proper handing of this within the front-end.
The source code of this exception looks as follows,
\lstinputlisting[language=Java]{../examples/frameworks/model/src/main/java/be/e_contract/model/ExistingItemException.java}

\section{JSF}
The JSF page looks as follows:
\lstinputlisting[language=XML]{../examples/frameworks/jsf/src/main/webapp/index.xhtml}
The corresponding CDI controller looks as follows:
\lstinputlisting[language=Java]{../examples/frameworks/jsf/src/main/java/be/e_contract/jsf/Controller.java}
The Maven POM file to build our project looks as follows:
\lstinputlisting[language=XML]{../examples/frameworks/jsf/pom.xml}

\section{Front-end Framework}
No matter which front-end framework we pick, we are forced to define a REST based API.
While we could do some ad-hoc JAX-RS API, we don't want to compromise on the "strong-typing" like we know from JSF.
We want that our server-side API is at all times in perfect sync with the client-side.
Hence this implies using OpenAPI and for the client-side a Typescript based framework.

The OpenAPI specification file looks as follows,
\lstinputlisting{../examples/frameworks/react/api/src/main/resources/openapi.yaml}
Important during the construction of the OpenAPI specification file is to pay special attention to the error handling.
While JSF inherently provides you with server-side based input validation, here you have to take care of the proper protocol definition regarding error handling yourself.

The Maven POM file to compile the OpenAPI towards JAX-RS interfaces looks as follows,
\lstinputlisting[language=XML]{../examples/frameworks/react/api/pom.xml}
While the \texttt{openapi-generator-maven-plugin} Maven plugin per default constructs an entire Maven project for you, I can hardly see why you would ever want that.
We only want the generated JAX-RS interfaces (and corresponding model), just like we did like 15 years ago with JAX-WS.
The Maven project is something we want to manage ourselves.
Hence via some configuration we instruct the \texttt{openapi-generator-maven-plugin} Maven plugin to limit itself to just do that.
Via some \texttt{build-helper-\allowbreak maven-plugin} magic we ensure that the generated JAX-RS interfaces actually also get compiled.

The implementation of the generated OpenAPI JAX-RS interface looks as follows,
\lstinputlisting[language=Java]{../examples/frameworks/react/war/src/main/java/be/e_contract/react/ItemApiImpl.java}
Two things pop out here:
\begin{itemize}
	\item When looking at the \texttt{add} method, we indeed are stuck with adding input validation manually.
	With JSF, this came for free.
	\item Within the \texttt{callList} method we have lovely message passing, mapping from one type to another.
	As Linus Torvalds once stated:
	\begin{quote}
		"message passing as the fundamental operation of the OS is just an exercise in computer science masturbation.
		It may feel good, but you donâ€™t actually get anything DONE."
	\end{quote}
	In JSF, we could directly use our JPA entities within the front-end.
\end{itemize}

Our \texttt{web.xml} web deployment descriptor to activate JAX-RS looks as follows,
\lstinputlisting[language=XML]{../examples/frameworks/react/war/src/main/webapp/WEB-INF/web.xml}

We also need to allow CORS since the WildFly application server and the (React) development server will typically run on a different port.
We do this by means of the following \texttt{WEB-INF/undertow-handlers.conf} configuration file for the Undertow web server.
\lstinputlisting{../examples/frameworks/react/war/src/main/webapp/WEB-INF/undertow-handlers.conf}
Obviously within production, this should get disabled.

\subsection{React}
As front-end framework we selected React.
Here we opted for a client-side rendering flavor, not a server-side rendering flavor with their so-called hydration simply because this is what JSF has been offering already for the last 20 years or so.

Luckily we now have \texttt{react-scripts} that voids the need to manage like 10 build files yourself.
So the React build system limits itself to one single \texttt{package.json} file, which is nice.
The \texttt{package.json} build file looks as follows:
\lstinputlisting{../examples/frameworks/react/war/src/main/react/package.json}
It is simple and understandable.

The HTML file looks as follows,
\lstinputlisting[language=XML]{../examples/frameworks/react/war/src/main/react/public/index.html}
Via the \texttt{app} identifier React will hook into our page at runtime.

As we don't want to loose the strong-typing as we know it from JSF, we opted for Typescript to define the React components.
The Typescript file looks as follows,
\lstinputlisting{../examples/frameworks/react/war/src/main/react/src/index.tsx}

Run the React application via:
\begin{lstlisting}[language=bash]
cd examples/frameworks/react/war/src/main/react
npm install
npm start
\end{lstlisting}

\begin{TODO}{Write Me}
	Write Me
\end{TODO}