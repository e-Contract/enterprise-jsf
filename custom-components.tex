% Enterprise JSF project.
%
% Copyright 2022 e-Contract.be BV. All rights reserved.
% e-Contract.be BV proprietary/confidential. Use is subject to license terms.

\chapter{Custom Components}

\section{Tag Library}

We structure the application as deployable EAR as depicted in Figure \ref{fig:ear}.
\begin{figure}[htbp]
	\begin{center}
		\includegraphics[scale=1.0]{ear}
		\caption{EAR project structure.}
		\label{fig:ear}
	\end{center}
\end{figure}
While you can put custom JSF components directly within your web application archive (WAR) file,
we strongly advice to directly isolate this within a separate JAR file.
Some reasons to do so:
\begin{itemize}
	\item Within larger teams, this allows developers to specialize and take responsibility over the custom JSF library.
	\item Most application have multiple portals, and hence multiple WAR files. For example: an end-user portal and an administrative portal. A separate JSF library allows you to use the library within different WAR artifacts.
	\item Directly isolating custom JSF components within their proper library makes it easier to later on propagate generic JSF components to for example a company-wide JSF library, or to push it even further towards open source.
\end{itemize}
The Maven parent POM of our project looks as follows.
\lstinputlisting[language=XML]{helloworld-ear/pom.xml}

The Maven POM of our tag library JAR module looks as follows.
\lstinputlisting[language=XML]{helloworld-ear/taglib/pom.xml}

The Maven POM of our WAR module looks as follows.
\lstinputlisting[language=XML]{helloworld-ear/war/pom.xml}
\begin{TIP}{Maven module naming}
	As you can notice, we use as \texttt{groupId} of project modules the concatenation
	of the \texttt{parent} \texttt{groupId} and \texttt{artifactId}.
	This has the advantage of yielding a clean result when pushing the project towards a Maven repository.
	Hence every artifact produced by this project, can be found under the same directory structure within the Maven repository.
\end{TIP}

The content of the WAR is similar to the initial example.

The Maven POM of our deployable EAR module looks as follows.
\lstinputlisting[language=XML]{helloworld-ear/ear/pom.xml}

The tag library itself is a regular JAR with some additional structure.
The most important file here is our \texttt{src/main/resources/META-INF/ejsf.taglib.xml} tag library descriptor file:
\lstinputlisting[language=XML,linerange=1-10]{helloworld-ear/taglib/src/main/resources/META-INF/ejsf.taglib.xml}
You can name this file anyway you want, as long as it ends with \texttt{.taglib.xml}.
Please notice that the above \texttt{.taglib.xml} tag library descriptor file already contains some declarations of custom tags that we will define later on.

Compile the example via:
\begin{lstlisting}[language=bash]
	cd helloworld-ear
	mvn clean install
\end{lstlisting}

Deploy the \texttt{helloworld-ear} EAR to the application server via:
\begin{lstlisting}[language=bash]
	cd ear
	mvn wildfly:deploy
\end{lstlisting}

Check out the deployed application within a web browser by navigating to:

http://localhost:8080/helloworld-ear/

\section{Validator}
\label{sec:validator}
We start off with our first custom JSF component, a validator.
\lstinputlisting[language=Java]{helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/validator/ExampleValidator.java}

We register this custom validator within our \texttt{.taglib.xml} tag library descriptor.
\lstinputlisting[language=XML,linerange=exampleValidator]{helloworld-ear/taglib/src/main/resources/META-INF/ejsf.taglib.xml}

Example usage of our custom validator is given below.
\lstinputlisting[language=XML]{helloworld-ear/war/src/main/webapp/validation.xhtml}
Hence entering "foobar" as input will result in a JSF message being displayed.


\subsection{Validator Parameters}
Validators can also be parameterized so we can influence its behavior at runtime. 
The custom JSF  validator with a parameter attribute looks as follows.
\lstinputlisting[language=Java]{helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/validator/ParameterValidator.java}

We register this custom validator within our \texttt{.taglib.xml} tag library descriptor.
\lstinputlisting[language=XML,linerange=parameterValidator]{helloworld-ear/taglib/src/main/resources/META-INF/ejsf.taglib.xml}

Example usage of our custom validator is given below.
\lstinputlisting[language=XML]{helloworld-ear/war/src/main/webapp/validation-parameter.xhtml}

\section{Output Component}
In this section we will construct our first "real" JSF component.
This component simply outputs its value.
The source code of our custom output JSF component is given below.
\lstinputlisting[language=Java]{helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/output/ExampleOutput.java}
Important here is to notice that we are setting the \texttt{id} attribute on our \texttt{span} HTML element to the value of client id.
This is required so that the JSF AJAX Javascript code can find our JSF component during response updates.
We also explicitly set the renderer type to \texttt{null} to prevent a warning when using Apache MyFaces \cite{myfaces} as JSF implementation.

We register this custom component within our \texttt{.taglib.xml} tag library descriptor.
\lstinputlisting[language=XML,linerange=exampleOutput]{helloworld-ear/taglib/src/main/resources/META-INF/ejsf.taglib.xml}

\begin{TIP}{XML Descriptors}
While JSF allows you to define the tag directly via the \texttt{@FacesComponent} annotation,
we prefer to use the classical XML descriptors for several reasons:
\begin{itemize}
	\item not everything can be declared via annotations.
	\item XML descriptors allow you to isolate the documentation of a component from the implementation.
	\item there is nothing wrong with XML, really.
\end{itemize}
\end{TIP}

Example usage of our custom output JSF component is given below.
\lstinputlisting[language=XML]{helloworld-ear/war/src/main/webapp/output.xhtml}
Notice that we selectively update our custom output component via the \texttt{render="output"} attribute on \texttt{f:ajax}.

\subsection{Output Component with Style}

In this example, we will create an output component that has been styled via a CSS file.
Suppose we have an enumerate, which we want to visualize using different colors.
\lstinputlisting[language=Java]{helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/output/ExampleEnum.java}

The JSF output component looks as follows:
\lstinputlisting[language=Java]{helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/output/ExampleStyledOutput.java}
Notice here that depending on the value of our enumerate, we change the \texttt{class} attribute value of our rendered \texttt{span} element.

The corresponding

\texttt{src/main/resources/META-INF/resources/ejsf/example-styled-output.css} CSS resource file looks as follows:
\lstinputlisting[language=CSS]{helloworld-ear/taglib/src/main/resources/META-INF/resources/ejsf/example-styled-output.css}

We register this custom component within our \texttt{.taglib.xml} tag library descriptor.
\lstinputlisting[language=XML,linerange=exampleStyledOutput]{helloworld-ear/taglib/src/main/resources/META-INF/ejsf.taglib.xml}

We can use this custom output component as follows,
\lstinputlisting[language=XML]{helloworld-ear/war/src/main/webapp/output-styled.xhtml}

With the corresponding CDI controller,
\lstinputlisting[language=Java]{helloworld-ear/war/src/main/java/be/e_contract/jsf/helloworld/EnumOutputController.java}


\section{Input Component}
In this section, we construct our first custom JSF input component.
Source code of our custom input JSF component is given below:
\lstinputlisting[language=Java]{helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/ExampleInput.java}
Notice again that we put an explicit \texttt{id} attribute containing the client id on our HTML output element so JSF AJAX updates can locate our component.

Our \texttt{input} element has a \texttt{name} attribute used to locate the request parameter during the \texttt{decode} phase.

Notice the usage of \texttt{getSubmittedValue()} and \texttt{setSubmittedValue()} during encoding and decoding.
The submitted value only gets propagated towards the actual value in case all input validators are happy.
Upon an input validation error, the component keeps working on the submitted value.

We register this custom component within our \texttt{.taglib.xml} tag library descriptor.
\lstinputlisting[language=XML,linerange=exampleInput]{helloworld-ear/taglib/src/main/resources/META-INF/ejsf.taglib.xml}

Example usage of our custom input JSF component is given below.
\lstinputlisting[language=XML]{helloworld-ear/war/src/main/webapp/input.xhtml}

\section{Rendering Children}
In this example, we demonstrate how to render your own children.
We do this by constructing our own \texttt{panelGrid} component.
The source code of this component is given below.
\lstinputlisting[language=Java]{helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/PanelGridComponent.java}
Via the \texttt{true} return value of the \texttt{getRendersChildren} we indicate that we render our child components ourselves.
This happens within the \texttt{encodeChildren} method, where we render each child component via \texttt{child.encodeAll}.

We register this custom component within our \texttt{.taglib.xml} tag library descriptor.
\lstinputlisting[language=XML,linerange=panelGrid]{helloworld-ear/taglib/src/main/resources/META-INF/ejsf.taglib.xml}

An example usage of our custom \texttt{panelGrid} component is given below.
\lstinputlisting[language=XML]{helloworld-ear/war/src/main/webapp/panel-grid.xhtml}


\section{AJAX Events}

Source code of our custom JSF component that can fire AJAX events is given below:
\lstinputlisting[language=Java]{helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/ExampleAjax.java}
Our component defines a \texttt{click} client-side event.
Within \texttt{encodeBegin} we weave in this client behavior event via the \texttt{onclick} Javascript hook.
At the server-side, we process our event within the \texttt{decode} method.
Here we first check whether our \texttt{click} event is part of the incoming request.
Next we verify whether it is really meant for our component, after which we delegate further decoding to the specific client behavior.

We register this custom component within our \texttt{.taglib.xml} tag library descriptor.
\lstinputlisting[language=XML,linerange=exampleAjax]{helloworld-ear/taglib/src/main/resources/META-INF/ejsf.taglib.xml}

Example usage of our custom JSF component is given below.
\lstinputlisting[language=XML]{helloworld-ear/war/src/main/webapp/ajax.xhtml}

With the corresponding CDI controller:
\lstinputlisting[language=Java]{helloworld-ear/war/src/main/java/be/e_contract/jsf/helloworld/AjaxController.java}

\subsection{Custom AJAX Events}

One can also create custom AJAX Events that can contain component specific parameters.
For example,
\lstinputlisting[language=Java]{helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/ExampleAjaxBehaviorEvent.java}

This custom AJAX event is passed as parameter to the CDI bean listener method as shown below.
\lstinputlisting[language=Java]{helloworld-ear/war/src/main/java/be/e_contract/jsf/helloworld/AjaxCustomEventController.java}

The following example JSF component demonstrates how to fire such custom AJAX JSF events.
\lstinputlisting[language=Java]{helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/ExampleAjaxEventComponent.java}
Only additional thing here is that, within \texttt{queueEvent}, we like upgrade the \texttt{AjaxBehaviorEvent} to our own flavor.

With the corresponding \texttt{example-ajax-event.js} Javascript resource file:
\lstinputlisting[language=Javascript]{helloworld-ear/taglib/src/main/resources/META-INF/resources/ejsf/example-ajax-event.js}

We register this custom component within our \texttt{.taglib.xml} tag library descriptor.
\lstinputlisting[language=XML,linerange=exampleAjaxEvent]{helloworld-ear/taglib/src/main/resources/META-INF/ejsf.taglib.xml}

Example usage of our custom JSF component is given below.
\lstinputlisting[language=XML]{helloworld-ear/war/src/main/webapp/ajax-event.xhtml}

\section{JSF Component with client-side API}
The JSF component source code,
\lstinputlisting[language=Java]{helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/ExampleWidget.java}
Notice that we set some \texttt{data-} attributes here, that will be picked up by our Javascript code.

The \texttt{ejsf-widget.js} Javascript resource:
\lstinputlisting[language=Javascript]{helloworld-ear/taglib/src/main/resources/META-INF/resources/ejsf/ejsf-widget.js}
Here we basically create a generic \texttt{Widget} class within the \texttt{ejsf} namespace that allows us to resolve widgets on the client-side using the \texttt{EJSF} method.
Via \texttt{registerWidgetType} we can register concrete widget classes.
During document loading, we instantiate all the widgets according to their registered type.

The \texttt{ejsf-widget-example.js} Javascript resource:
\lstinputlisting[language=Javascript]{helloworld-ear/taglib/src/main/resources/META-INF/resources/ejsf/ejsf-widget-example.js}
Our \texttt{ExampleWidget} simple exposes a \texttt{setValue} method to change the content of the widget element.
Further we register our widget type so it can get picked up during page loading.

We register this custom component within our \texttt{.taglib.xml} tag library descriptor.
\lstinputlisting[language=XML,linerange=exampleWidget]{helloworld-ear/taglib/src/main/resources/META-INF/ejsf.taglib.xml}

Example usage of our custom JSF component is given below.
\lstinputlisting[language=XML]{helloworld-ear/war/src/main/webapp/widget.xhtml}

\section{Client Behavior}
Example client behavior where we change the color of the button when we move over the mouse.
Example usage of this custom client behavior is given below.
\lstinputlisting[language=XML]{helloworld-ear/war/src/main/webapp/client-behavior.xhtml}

The custom client behavior source code,
\lstinputlisting[language=Java]{helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/behavior/ExampleClientBehavior.java}

The corresponding renderer:
\lstinputlisting[language=Java]{helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/behavior/ExampleClientBehaviorRenderer.java}

The tag handler:
\lstinputlisting[language=Java]{helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/behavior/ExampleClientBehaviorTagHandler.java}
Important here is to instantiate the custom behavior via \texttt{application.createBehavior} to ensure that the \texttt{@ResourceDependency} annotations on the renderer are interpreted by JSF.

The \texttt{example-client-behavior.js} JavaScript resource:
\lstinputlisting[language=Javascript]{helloworld-ear/taglib/src/main/resources/META-INF/resources/ejsf/example-client-behavior.js}

The \texttt{example-client-behavior.css} CSS resource:
\lstinputlisting[language=CSS]{helloworld-ear/taglib/src/main/resources/META-INF/resources/ejsf/example-client-behavior.css}

We register this custom component within our \texttt{.taglib.xml} tag library descriptor.
\lstinputlisting[language=XML,linerange=exampleClientBehavior]{helloworld-ear/taglib/src/main/resources/META-INF/ejsf.taglib.xml}

\section{Composites}
JSF also allows us to define component entirely within XHTML.
An example composite components \texttt{exampleComposite.xhtml} is given below.
\lstinputlisting[language=XML]{helloworld-ear/taglib/src/main/resources/META-INF/resources/ejsf/exampleComposite.xhtml}
Important here is to put a proper \texttt{id} attribute with \texttt{cc.clientId} value so the JSF AJAX updates can locate our composite component.

Example usage of our composite component is given below.
\lstinputlisting[language=XML]{helloworld-ear/war/src/main/webapp/composite.xhtml}

\subsection{Backing Component}
A composite component can also be further enhanced using a backing component.
We demonstrate such construct within the following example.
This composite component allows us to input a period (days and hours).
The \texttt{inputPeriod.xhtml} composite component XHTML source is given below.
\lstinputlisting[language=XML]{helloworld-ear/taglib/src/main/resources/META-INF/resources/ejsf/inputPeriod.xhtml}
Via the \texttt{componentType} attribute we refer to the backing component.
Using the \texttt{binding} attribute we bind JSF components to our backing component.

The corresponding backing component source code is given below.
\lstinputlisting[language=Java]{helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/ExampleBackingComponent.java}
Notice here to setup of both \texttt{encodeBegin} and \texttt{processDecodes} methods.
We have to correctly handle the value of submitted value here to ensure that input validations on our composite component use the correct intermediate value at all times. E.g., if an input validation occurs on value "xyz", an update of our component should still display "xyz".

Example usage of our composite component with backing component is given below:
\lstinputlisting[language=XML]{helloworld-ear/war/src/main/webapp/composite-input.xhtml}
With the corresponding CDI controller given by,
\lstinputlisting[language=Java]{helloworld-ear/war/src/main/java/be/e_contract/jsf/helloworld/InputPeriodController.java}

\subsection{Children and Facets}
In the following composite component we demonstrate the usage of children and facets.
The source code of our \texttt{panel.xhtml} composite component is given below.
\lstinputlisting[language=XML]{helloworld-ear/taglib/src/main/resources/META-INF/resources/ejsf/panel.xhtml}
Notice that we have to declare our custom facet, named \texttt{footer},
via the \texttt{cc:facet} element within the \texttt{cc:interface} section of our composite component.
Notice that the panel footer is only rendered when the \texttt{footer} facet has been set.

The corresponding CSS resource file is given below.
\lstinputlisting[language=CSS]{helloworld-ear/taglib/src/main/resources/META-INF/resources/ejsf/panel.css}

An example usage of our panel composite component is given below.
\lstinputlisting[language=XML]{helloworld-ear/war/src/main/webapp/composite-panel.xhtml}

\section{Value Expressions}

\section{Method Expressions}
The demonstrate the usage of \texttt{MethodExpression} we construct a custom \texttt{Converter}.
The source code of our custom converter is given below.
\lstinputlisting[language=Java]{helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/converter/GenericConverter.java}
This custom \texttt{Converter} simply delegates its method implementations towards method expressions.
Notice that we implement the \texttt{StateHolder} interface to ensure that the state of our converter gets properly saved and recovered.

Via a tag handler we attach our custom converter to its input parent component.
The source code of our tag handler is given below.
\lstinputlisting[language=Java]{helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/converter/GenericConverterTagHandler.java}

We register this custom component within our \texttt{.taglib.xml} tag library descriptor.
\lstinputlisting[language=XML,linerange=genericConverter]{helloworld-ear/taglib/src/main/resources/META-INF/ejsf.taglib.xml}

Example usage within a JSF page of our custom converter is given below.
\lstinputlisting[language=XML]{helloworld-ear/war/src/main/webapp/generic-converter.xhtml}
The \texttt{getAsObject} and \texttt{getAsString} attributes on our custom converter are interpreted as method expressions.

With the corresponding CDI controller given below.
\lstinputlisting[language=Java]{helloworld-ear/war/src/main/java/be/e_contract/jsf/helloworld/GenericConverterController.java}


\section{Dynamic Components}
In this section we demonstrate how to construct dynamic components, i.e., components that change behavior at runtime.
Imagine we have a list of objects, each object has its own type as shown in the following example controller.
\lstinputlisting[language=Java]{helloworld-ear/war/src/main/java/be/e_contract/jsf/helloworld/DataController.java}

We now want to construct a component that is capable of inputting this dynamic typed value, as shown in the example below.
\lstinputlisting[language=XML]{helloworld-ear/war/src/main/webapp/dynamic-input.xhtml}

Our JSF component for this looks as follows.
\lstinputlisting[language=Java]{helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/DynamicInputComponent.java}
Via the \texttt{PostAddToViewEvent} event we add specific input components to the component tree within the \texttt{processEvent} method.
Notice here that we add all possible input components here,  since at this point we don't know yet which exact type will be required at render/decode time.
Via the \texttt{getRendersChildren} method we indicate that we will take care of rendering/decoding our children.
And this is exactly what we do within the \texttt{encodeChildren} and \texttt{decode} methods where we delegate towards the appropriate child component.

We register this custom component within our \texttt{.taglib.xml} tag library descriptor.
\lstinputlisting[language=XML,linerange=dynamicInput]{helloworld-ear/taglib/src/main/resources/META-INF/ejsf.taglib.xml}

\section{Facets}

\section{UIData}
The source code of our custom \texttt{UIData} component is given below.
\lstinputlisting[language=Java]{helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/datalist/DataList.java}

The source code of the corresponding rendered is given below.
\lstinputlisting[language=Java]{helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/datalist/DataListRenderer.java}

We register this custom component within our \texttt{.taglib.xml} tag library descriptor.
\lstinputlisting[language=XML,linerange=dataList]{helloworld-ear/taglib/src/main/resources/META-INF/ejsf.taglib.xml}

\begin{TODO}{Input decoding}
	Seems like the input decoding is missing from the above component.
\end{TODO}


\section{EL functions}
In this section we demonstrate how to add custom EL functions.
In the following example we use our custom \texttt{gcd} function to calculate the greatest common divisor of two given numbers.
\lstinputlisting[language=XML]{helloworld-ear/war/src/main/webapp/custom-function.xhtml}

This function is simply defined as a static function as shown below.
\lstinputlisting[language=Java]{helloworld-ear/taglib/src/main/java/be/e_contract/jsf/taglib/GreatestCommonDivisor.java}

We register this custom function within our \texttt{.taglib.xml} tag library descriptor as follows.
\lstinputlisting[language=XML,linerange=gcd]{helloworld-ear/taglib/src/main/resources/META-INF/ejsf.taglib.xml}
